#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# remove warnings for constants (coming for macOS)
# ruff: noqa: N816

import base64
import pathlib
from string import Template
import struct
from typing import Literal

from iir.filter_iir import Biquad, q2bw, bw2q
from iir.filter_peq import peq_preamp_gain, Peq

SRATE = 48000

# types
IIR = list[dict[str, int | float]]
STATUS = Literal[True] | Literal[False]


# ----------------------------------------------------------------------
# AUPRESET
# ----------------------------------------------------------------------


def guess_format(lines: list[str]) -> str:
    has_q = False
    has_bw = False
    has_width = False
    has_filter = False
    for line in lines:
        if line.find("AU_N-Band_EQ") != -1:
            has_width = True
        if line.find("Filter ") != -1:
            has_filter = True
        if line.find(" Q ") != -1:
            has_q = True
        if line.find(" BW ") != -1:
            has_bw = True

    if has_width:
        # generated by REW for AUNBandEQ
        return "AUNBandEQ"

    if has_filter and (has_q or has_bw):
        # more or less EQ APO format / used by autoEQ too
        return "APO"

    return "Unknown"


def parse_aunbandeq(lines: list[str]) -> tuple[STATUS, IIR]:
    iir = []
    for line in lines:
        tokens = line.split()
        len_tokens = len(tokens)
        # print(len_tokens, line)
        if len_tokens != 8 or tokens[0] == "Number" or tokens[3] == "None":
            # print('DEBUG dropping line {}'.format(line))
            continue
        iir.append(
            {
                "type": tokens[3],
                "freq": float(tokens[4]),
                "gain": float(tokens[5]),
                "width": float(tokens[6]),
            }
        )
    return True, iir


def parse_apo(lines: list[str]) -> tuple[STATUS, IIR]:
    iir = []
    for line in lines:
        tokens = line.split()
        len_tokens = len(tokens)
        # print(len_tokens, line)
        if (
            len_tokens > 0
            and tokens[0] == "Filter"
            and tokens[2] == "ON"
            and tokens[3] != "None"
        ):
            if len_tokens == 12:
                iir.append(
                    {
                        "type": tokens[3],
                        "freq": float(tokens[5]),
                        "gain": float(tokens[8]),
                        "q": float(tokens[11]),
                        "width": q2bw(float(tokens[11])),
                    }
                )
            elif len_tokens == 13:
                iir.append(
                    {
                        "type": tokens[3],
                        "freq": float(tokens[5]),
                        "gain": float(tokens[8]),
                        "q": bw2q(float(tokens[12])),
                        "width": float(tokens[12]),
                    }
                )
    return True, iir


def iir2peq(iir: IIR) -> Peq:
    peq = []
    for biquad in iir:
        biquad_type = {
            "PK": Biquad.PEAK,
            "LP": Biquad.LOWPASS,
            "HP": Biquad.HIGHPASS,
            "LS": Biquad.LOWSHELF,
            "HS": Biquad.HIGHSHELF,
            "BP": Biquad.BANDPASS,
            "LSC": Biquad.LOWSHELF,  # Low Shelf Cut - use same as Low Shelf
            "HSC": Biquad.HIGHSHELF,  # High Shelf Cut - use same as High Shelf
        }.get(str(biquad["type"]))
        if biquad_type is None:
            continue
        freq = biquad["freq"]
        gain = biquad["gain"]
        width = biquad["width"]
        q = bw2q(width)
        peq.append((1.0, Biquad(biquad_type, freq, SRATE, q, gain)))
    return peq


def lines2iir(lines: list[str]) -> tuple[STATUS, IIR]:
    option = guess_format(lines)
    if option == "AUNBandEQ":
        return parse_aunbandeq(lines)
    elif option == "APO":
        return parse_apo(lines)
    return True, []


# ----------------------------------------------------------------------
# AUPRESET
# ----------------------------------------------------------------------

PRESET_DIR = pathlib.PosixPath(
    "~/Library/Audio/Presets/Apple/AUNBandEQ"
).expanduser()

# https://developer.apple.com/documentation/audiotoolbox/1389745-aunbandeq_parameters
kAUNBandEQParam_BypassBand = 1000
kAUNBandEQParam_FilterType = 2000
kAUNBandEQParam_Frequency = 3000
kAUNBandEQParam_Gain = 4000
kAUNBandEQParam_Bandwidth = 5000
kAUNBandEQParam_GlobalGain = 0
#
kAUNBandEQProperty_NumberOfBands = 2200
kAUNBandEQProperty_MaxNumberOfBands = 2201
kAUNBandEQProperty_BiquadCoefficients = 2203
#
kAUNBandEQFilterType_Parametric = 0
kAUNBandEQFilterType_2ndOrderButterworthLowPass = 1
kAUNBandEQFilterType_2ndOrderButterworthHighPass = 2
kAUNBandEQFilterType_ResonantLowPass = 3
kAUNBandEQFilterType_ResonantHighPass = 4
kAUNBandEQFilterType_BandPass = 5
kAUNBandEQFilterType_BandStop = 6
kAUNBandEQFilterType_LowShelf = 7
kAUNBandEQFilterType_HighShelf = 8
kAUNBandEQFilterType_ResonantLowShelf = 9
kAUNBandEQFilterType_ResonantHighShelf = 10
kNumAUNBandEQFilterTypes = 11

# plist template, could also use a library
AUPRESET_TEMPLATE = Template(
    '\
<?xml version="1.0" encoding="UTF-8"?>\n\
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n\
<plist version="1.0">\n\
<dict>\n\
	<key>ParametricType</key>\n\
	<integer>11</integer>\n\
	<key>data</key>\n\
	<data>\n\
$data\n\
	</data>\n\
	<key>manufacturer</key>\n\
	<integer>1634758764</integer>\n\
	<key>name</key>\n\
	<string>$name</string>\n\
	<key>numberOfBands</key>\n\
	<integer>$number_of_bands</integer>\n\
	<key>subtype</key>\n\
	<integer>1851942257</integer>\n\
	<key>type</key>\n\
	<integer>1635083896</integer>\n\
	<key>version</key>\n\
	<integer>0</integer>\n\
</dict>\n\
</plist>\n\
'
)


def file2iir(filename: str) -> tuple[STATUS, IIR]:
    with open(filename, "r", encoding="utf-8") as fd:
        lines = fd.readlines()
        return lines2iir(lines)
    return False, []


def iir2data(iir: IIR) -> tuple[STATUS, int, str]:
    """Build the data field from an iir"""

    def type2value(t: str) -> int:
        """Transform a IIR type into the corresponding value for AUNBandEQ"""
        val = {
            "PK": kAUNBandEQFilterType_Parametric,
            "HS": kAUNBandEQFilterType_HighShelf,
            "LS": kAUNBandEQFilterType_LowShelf,
            "HP": kAUNBandEQFilterType_ResonantHighPass,
            "LP": kAUNBandEQFilterType_ResonantLowPass,
            "BP": kAUNBandEQFilterType_BandPass,
            "LSC": kAUNBandEQFilterType_ResonantLowShelf,  # Low Shelf Cut
            "HSC": kAUNBandEQFilterType_ResonantHighShelf,  # High Shelf Cut
        }.get(t, -1)
        if val == -1:
            print(
                "error in eq: {} is not supported yet, contact developer please!".format(
                    t
                )
            )
        return val

    len_iir = len(iir)
    # print(len_iir)
    # print(iir)

    peq = iir2peq(iir)
    preamp_gain = peq_preamp_gain(peq)

    params = {}
    for i, current_iir in enumerate(iir):
        params["{:d}".format(kAUNBandEQParam_BypassBand + i)] = 0.0  # True
        params["{:d}".format(kAUNBandEQParam_FilterType + i)] = type2value(
            str(current_iir["type"])
        )
        params["{:d}".format(kAUNBandEQParam_Frequency + i)] = float(
            current_iir["freq"]
        )
        params["{:d}".format(kAUNBandEQParam_Gain + i)] = float(
            current_iir["gain"]
        )
        params["{:d}".format(kAUNBandEQParam_Bandwidth + i)] = float(
            current_iir["width"]
        )

    # remainings EQ are required and are set to 0
    for i in range(len_iir, 16):
        params["{:d}".format(kAUNBandEQParam_BypassBand + i)] = 1.0  # False
        params["{:d}".format(kAUNBandEQParam_FilterType + i)] = 0
        params["{:d}".format(kAUNBandEQParam_Frequency + i)] = 0.0
        params["{:d}".format(kAUNBandEQParam_Gain + i)] = 0.0
        params["{:d}".format(kAUNBandEQParam_Bandwidth + i)] = 0.0

    # some black magic, data is padded, the only important values are
    # 3. number of parameters + 1
    # 5. db_gain

    # need to check if length is variable or not
    # ndata = 5
    # for current_iir in iir:
    #    ndata += 2
    #    if current_iir["type"] == "PK":
    #        ndata += 3
    #    elif current_iir["type"] in ("LS", "HS", "BP", "BS", "RLP", "RHP"):
    #        ndata += 2
    #    elif current_iir["type"] in ("BLP", "BHP"):
    #        ndata += 1

    ndata = 81
    buffer = struct.pack(">llllf", 0, 0, ndata, 0, preamp_gain)

    # add pairs of (param_id, value) in big endian
    # it looks like Apple now sort them
    for param_id, value in sorted(params.items()):
        if param_id[0] in ("2"):
            # value is unsigned int https://developer.apple.com/documentation/audiotoolbox/audiounitparameterid
            # buffer += struct.pack(">ll", int(param_id), value)
            buffer += struct.pack(">lf", int(param_id), float(value))
        else:
            # value is a float
            buffer += struct.pack(">lf", int(param_id), value)

    # convert the byte buffer to base64
    text = base64.standard_b64encode(buffer).decode("ascii")

    # add \t and slice in chunks of 68 chars
    nchunks = 68
    len_text = len(text) // nchunks
    slices = [
        "\t{}\n".format(text[i * nchunks : (i + 1) * nchunks])
        for i in range(len_text)
    ]
    slices += ["\t{}".format(text[len_text * nchunks :])]

    return True, len_iir, "".join(slices)


def iir2aupreset(iir: list, name: str) -> tuple[STATUS, str]:
    status, nbands, data = iir2data(iir)
    if not status:
        return status, ""
    return True, AUPRESET_TEMPLATE.substitute(
        data=data, name=name, number_of_bands=nbands
    )


# ----------------------------------------------------------------------
# RME
# ----------------------------------------------------------------------


def get_filter_priority(filter_type: str) -> int:
    """Get priority for filter type (higher number = higher priority).
    
    Args:
        filter_type: The type of filter (PK, LS, HS, LSC, HSC, LP, HP, etc.)
        
    Returns:
        Priority value (higher = more important to keep)
    """
    priorities = {
        'LSC': 10,  # Low shelf cut - very important for overall curve
        'HSC': 10,  # High shelf cut - very important for overall curve
        'LS': 9,    # Low shelf - important for overall curve
        'HS': 9,    # High shelf - important for overall curve
        'LP': 7,    # Low pass - medium priority
        'HP': 7,    # High pass - medium priority
        'BP': 5,    # Band pass - lower priority
        'PK': 3,    # Peak - lowest priority (most common, easiest to sacrifice)
    }
    return priorities.get(filter_type, 1)  # Default to low priority


def filter_iirs_by_gain(iirs: list, max_count: int) -> list:
    """Filter IIRs while preserving order and prioritizing important filter types.
    
    Args:
        iirs: List of IIR filter dictionaries in original order
        max_count: Maximum number of IIRs to keep
        
    Returns:
        List of IIRs in original order, limited to max_count, with low-priority/low-gain filters removed
    """
    if len(iirs) <= max_count:
        return iirs
    
    # Create list of (index, iir, priority, abs_gain) for sorting
    indexed_iirs = []
    for i, iir in enumerate(iirs):
        priority = get_filter_priority(iir.get('type', 'PK'))
        abs_gain = abs(iir.get('gain', 0.0))
        indexed_iirs.append((i, iir, priority, abs_gain))
    
    # Sort by priority (descending) then by absolute gain (descending)
    # This puts high-priority, high-gain filters first
    indexed_iirs.sort(key=lambda x: (x[2], x[3]), reverse=True)
    
    # Take the top max_count filters
    selected = indexed_iirs[:max_count]
    
    # Sort selected filters back to original order by index
    selected.sort(key=lambda x: x[0])
    
    # Extract just the IIR dictionaries
    return [item[1] for item in selected]


def type2rme(t: str, pos: int) -> float:
    # ---------------
    # pk       = 0
    # shelving = 1
    # low pass = 3 if first one and 2 is last one
    # high pass = 2 if first one and 3 is last one
    # ---------------
    if t == "PK":
        return 0.0
    elif t == "LP":
        if pos == 1:
            return 3.0
        elif pos == 3 or pos == 9:
            return 2.0
    elif t == "HP":
        if pos == 1:
            return 2.0
        elif pos == 3 or pos == 9:
            return 3.0
    elif t in ("HS", "HSC", "LS", "LSC") and (pos == 1 or pos == 3 or pos == 9):
        return 1.0

    # either wrong position or unknown type
    return -1.0


def iir2rme_totalmix_channel(iirs: list) -> tuple[STATUS, str]:
    # Check IIR filter limit for TotalMix channel EQ (max 3 bands)
    if len(iirs) > 3:
        print(f"Error: TotalMix channel EQ supports a maximum of 3 bands. {len(iirs)} bands were provided.")
        return False, ""

    lines = []
    lines.append("<Preset>")
    lines.append("  <Equalizer>")
    lines.append("    <Params>")
    # for now, default
    lines.append('	<val e="LC Grade" v="1.00,"/>')
    lines.append('	<val e="LC Freq" v="20.00,"/>')
    for i, iir in enumerate(iirs):
        q = iir.get("q", 0.0)
        if "q" not in iir and "width" in iir:
            q = bw2q(iir["width"])
        lines.append(
            '      <val e="Band{} Freq" v="{:7.2f},"/>'.format(
                i + 1, iir["freq"]
            )
        )
        lines.append('      <val e="Band{} Q" v="{:4.2f},"/>'.format(i + 1, q))
        lines.append(
            '        <val e="Band{} Gain" v="{:4.2f},"/>'.format(
                i + 1, iir["gain"]
            )
        )
    for i, iir in enumerate(iirs):
        rme = type2rme(iir["type"], i + 1)
        if rme == -1:
            print("skip eq {} type is unknown {}".format(i, iir["type"]))
            continue
        lines.append(
            '        <val e="Band{} Type" v="{:4.2f},"/>'.format(i + 1, rme)
        )
    lines.append("    </Params>")
    lines.append("  </Equalizer>")
    lines.append("</Preset>")
    return True, "\n".join(lines)


def enforce_rme_room_filter_constraints(iirs: list) -> list:
    """Enforce RME room EQ constraints on LSC and HSC filters.
    
    Args:
        iirs: List of IIR filter dictionaries
        
    Returns:
        List of IIRs with RME room EQ constraints applied:
        - At most 1 LSC filter (positioned first if present)
        - At most 1 HSC filter (positioned last if present)
        - Other filters preserved in their relative order
    """
    if not iirs:
        return iirs
    
    # Separate filters by type
    lsc_filters = []
    hsc_filters = []
    other_filters = []
    
    for iir in iirs:
        filter_type = iir.get('type', '')
        if filter_type == 'LSC':
            lsc_filters.append(iir)
        elif filter_type == 'HSC':
            hsc_filters.append(iir)
        else:
            other_filters.append(iir)
    
    # Select at most one LSC filter (prefer highest absolute gain)
    selected_lsc = None
    if lsc_filters:
        selected_lsc = max(lsc_filters, key=lambda x: abs(x.get('gain', 0.0)))
    
    # Select at most one HSC filter (prefer highest absolute gain)
    selected_hsc = None
    if hsc_filters:
        selected_hsc = max(hsc_filters, key=lambda x: abs(x.get('gain', 0.0)))
    
    # Reorder: LSC first, other filters in middle, HSC last
    result = []
    if selected_lsc:
        result.append(selected_lsc)
    result.extend(other_filters)
    if selected_hsc:
        result.append(selected_hsc)
    
    return result


def iir2rme_totalmix_room(left: list, right: list) -> tuple[STATUS, str]:
    # Apply RME room EQ constraints for LSC and HSC filters
    left = enforce_rme_room_filter_constraints(left)
    right = enforce_rme_room_filter_constraints(right)
    
    # Check IIR filter limits for TotalMix room EQ (max 9 bands per channel)
    original_left_count = len(left)
    original_right_count = len(right)

    # Filter left channel if needed
    if len(left) > 9:
        left = filter_iirs_by_gain(left, 9)

    # Filter right channel if needed
    if len(right) > 9:
        right = filter_iirs_by_gain(right, 9)

    # Print warning if any channel was filtered
    if original_left_count > 9 or original_right_count > 9:
        print(f"Warning: TotalMix room EQ supports a maximum of 9 bands per channel. "
              f"Left channel has {original_left_count} bands, right channel has {original_right_count} bands. "
              f"Keeping the 9 bands with highest absolute gain.")

    lines = []

    def process(iirs: list):
        for i, iir in enumerate(iirs):
            q = iir.get("q", 0.0)
            if "q" not in iir and "width" in iir:
                q = bw2q(iir["width"])
            lines.append(
                '        <val e="REQ Band{} Freq" v="{:7.2f},"/>'.format(
                    i + 1, iir["freq"]
                )
            )
            lines.append(
                '        <val e="REQ Band{} Q" v="{:4.2f},"/>'.format(i + 1, q)
            )
            lines.append(
                '        <val e="REQ Band{} Gain" v="{:4.2f},"/>'.format(
                    i + 1, iir["gain"]
                )
            )

        for i, iir in enumerate(iirs):
            rme = type2rme(iir["type"], i + 1)
            if rme == -1:
                print("skip eq at pos {} type is unknown {}", i+1, iir["type"])
                continue
            lines.append(
                '        <val e="REQ Band{} Type" v="{:4.2f},"/>'.format(
                    i + 1, rme
                )
            )

    lines.append("<Preset>")

    preamp_gain = 0.0
    lines.append("  <Room EQ L>")
    lines.append("    <Params>")
    lines.append('	<val e="REQ Delay" v="0.00,"/>')
    process(left)
    lines.append('	<val e="REQ Chan Gain" v="{},"/>'.format(preamp_gain))
    lines.append("    </Params>")
    lines.append("  </Room EQ L>")

    preamp_gain = 0.0
    lines.append("  <Room EQ R>")
    lines.append("    <Params>")
    lines.append('	<val e="REQ Delay" v="0.00,"/>')
    if len(right) > 0:
        process(right)
    else:
        process(left)
    lines.append('	<val e="REQ Chan Gain" v="{},"/>'.format(preamp_gain))
    lines.append("    </Params>")
    lines.append("  </Room EQ R>")

    lines.append("</Preset>")
    return True, "\n".join(lines)
