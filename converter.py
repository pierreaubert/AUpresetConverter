#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import base64
import pathlib
from string import Template
import struct
from typing import Literal

import reflex as rx

from iir.filter_iir import Biquad, q2bw, bw2q
from iir.filter_peq import peq_preamp_gain, Peq

SRATE = 48000

PRESET_DIR = pathlib.PosixPath(
    "~/Library/Audio/Presets/Apple/AUNBandEQ"
).expanduser()

# https://developer.apple.com/documentation/audiotoolbox/1389745-aunbandeq_parameters
kAUNBandEQParam_BypassBand = 1000
kAUNBandEQParam_FilterType = 2000
kAUNBandEQParam_Frequency = 3000
kAUNBandEQParam_Gain = 4000
kAUNBandEQParam_Bandwidth = 5000
kAUNBandEQParam_GlobalGain = 0
#
kAUNBandEQProperty_NumberOfBands = 2200
kAUNBandEQProperty_MaxNumberOfBands = 2201
kAUNBandEQProperty_BiquadCoefficients = 2203
#
kAUNBandEQFilterType_Parametric = 0
kAUNBandEQFilterType_2ndOrderButterworthLowPass = 1
kAUNBandEQFilterType_2ndOrderButterworthHighPass = 2
kAUNBandEQFilterType_ResonantLowPass = 3
kAUNBandEQFilterType_ResonantHighPass = 4
kAUNBandEQFilterType_BandPass = 5
kAUNBandEQFilterType_BandStop = 6
kAUNBandEQFilterType_LowShelf = 7
kAUNBandEQFilterType_HighShelf = 8
kAUNBandEQFilterType_ResonantLowShelf = 9
kAUNBandEQFilterType_ResonantHighShelf = 10
kNumAUNBandEQFilterTypes = 11

# plist template, could also use a library
AUPRESET_TEMPLATE = Template(
    '\
<?xml version="1.0" encoding="UTF-8"?>\n\
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n\
<plist version="1.0">\n\
<dict>\n\
	<key>ParametricType</key>\n\
	<integer>11</integer>\n\
	<key>data</key>\n\
	<data>\n\
$data\n\
	</data>\n\
	<key>manufacturer</key>\n\
	<integer>1634758764</integer>\n\
	<key>name</key>\n\
	<string>$name</string>\n\
	<key>numberOfBands</key>\n\
	<integer>$number_of_bands</integer>\n\
	<key>subtype</key>\n\
	<integer>1851942257</integer>\n\
	<key>type</key>\n\
	<integer>1635083896</integer>\n\
	<key>version</key>\n\
	<integer>0</integer>\n\
</dict>\n\
</plist>\n\
'
)

# types
IIR = list[dict[str, int | float]]
STATUS = Literal[0] | Literal[1]


def guess_format(lines: list[str]) -> str:
    has_q = False
    has_bw = False
    has_width = False
    has_filter = False
    for line in lines:
        if line.find("AU_N-Band_EQ") != -1:
            has_width = True
        if line.find("Filter ") != -1:
            has_filter = True
        if line.find(" Q ") != -1:
            has_q = True
        if line.find(" BW ") != -1:
            has_bw = True

    if has_width:
        # generated by REW for AUNBandEQ
        return "AUNBandEQ"

    if has_filter and (has_q or has_bw):
        # more or less EQ APO format / used by autoEQ too
        return "APO"

    return "Unknown"


def parse_aunbandeq(lines: list[str]) -> tuple[STATUS, IIR]:
    iir = []
    for line in lines:
        tokens = line.split()
        len_tokens = len(tokens)
        # print(len_tokens, line)
        if len_tokens != 8 or tokens[0] == "Number" or tokens[3] == "None":
            # print('DEBUG dropping line {}'.format(line))
            continue
        iir.append(
            {
                "type": tokens[3],
                "freq": float(tokens[4]),
                "gain": float(tokens[5]),
                "width": float(tokens[6]),
            }
        )
    return 0, iir


def parse_apo(lines: list[str]) -> tuple[STATUS, IIR]:
    iir = []
    for line in lines:
        tokens = line.split()
        len_tokens = len(tokens)
        # print(len_tokens, line)
        if (
            len_tokens > 0
            and tokens[0] == "Filter"
            and tokens[2] == "ON"
            and tokens[3] != "None"
        ):
            if len_tokens == 12:
                iir.append(
                    {
                        "type": tokens[3],
                        "freq": float(tokens[5]),
                        "gain": float(tokens[8]),
                        "q": float(tokens[11]),
                        "width": q2bw(float(tokens[11])),
                    }
                )
            elif len_tokens == 13:
                iir.append(
                    {
                        "type": tokens[3],
                        "freq": float(tokens[5]),
                        "gain": float(tokens[8]),
                        "q": bw2q(float(tokens[12])),
                        "width": float(tokens[12]),
                    }
                )
    return 0, iir


def iir2peq(iir: IIR) -> Peq:
    peq = []
    for biquad in iir:
        biquad_type = {
            "PK": Biquad.PEAK,
            "LP": Biquad.LOWPASS,
            "HP": Biquad.HIGHPASS,
            "LS": Biquad.LOWSHELF,
            "HS": Biquad.HIGHSHELF,
            "BP": Biquad.BANDPASS,
        }.get(str(biquad["type"]))
        if biquad_type is None:
            continue
        freq = biquad["freq"]
        gain = biquad["gain"]
        width = biquad["width"]
        q = bw2q(width)
        peq.append((1.0, Biquad(biquad_type, freq, SRATE, q, gain)))
    return peq


def lines2iir(lines: list[str]) -> tuple[STATUS, IIR]:
    option = guess_format(lines)
    rx.console_log("Guessed: {} format".format(option))
    if option == "AUNBandEQ":
        return parse_aunbandeq(lines)
    elif option == "APO":
        return parse_apo(lines)
    return 1, []


def rew2iir(filename: str) -> tuple[STATUS, IIR]:
    with open(filename, "r", encoding="utf-8") as fd:
        lines = fd.readlines()
        return lines2iir(lines)
    return 1, []


def iir2data(iir: IIR) -> tuple[STATUS, int, str]:
    """Build the data field from an iir"""

    def type2value(t: str) -> int:
        """Transform a IIR type into the corresponding value for AUNBandEQ"""
        val = {
            "PK": kAUNBandEQFilterType_Parametric,
            "HS": kAUNBandEQFilterType_HighShelf,
            "LS": kAUNBandEQFilterType_LowShelf,
            "HP": kAUNBandEQFilterType_ResonantHighPass,
            "LP": kAUNBandEQFilterType_ResonantLowPass,
            "BP": kAUNBandEQFilterType_BandPass,
        }.get(t, -1)
        if val == -1:
            print(
                "error in eq: {} is not supported yet, contact developer please!".format(
                    t
                )
            )
        return val

    len_iir = len(iir)
    # print(len_iir)
    # print(iir)

    peq = iir2peq(iir)
    preamp_gain = peq_preamp_gain(peq)

    params = {}
    for i, current_iir in enumerate(iir):
        params["{:d}".format(kAUNBandEQParam_BypassBand + i)] = 0.0  # True
        params["{:d}".format(kAUNBandEQParam_FilterType + i)] = type2value(
            str(current_iir["type"])
        )
        params["{:d}".format(kAUNBandEQParam_Frequency + i)] = float(
            current_iir["freq"]
        )
        params["{:d}".format(kAUNBandEQParam_Gain + i)] = float(
            current_iir["gain"]
        )
        params["{:d}".format(kAUNBandEQParam_Bandwidth + i)] = float(
            current_iir["width"]
        )

    # remainings EQ are required and are set to 0
    for i in range(len_iir, 16):
        params["{:d}".format(kAUNBandEQParam_BypassBand + i)] = 1.0  # False
        params["{:d}".format(kAUNBandEQParam_FilterType + i)] = 0
        params["{:d}".format(kAUNBandEQParam_Frequency + i)] = 0.0
        params["{:d}".format(kAUNBandEQParam_Gain + i)] = 0.0
        params["{:d}".format(kAUNBandEQParam_Bandwidth + i)] = 0.0

    # some black magic, data is padded, the only important values are
    # 3. number of parameters + 1
    # 5. db_gain

    # need to check if length is variable or not
    # ndata = 5
    # for current_iir in iir:
    #    ndata += 2
    #    if current_iir["type"] == "PK":
    #        ndata += 3
    #    elif current_iir["type"] in ("LS", "HS", "BP", "BS", "RLP", "RHP"):
    #        ndata += 2
    #    elif current_iir["type"] in ("BLP", "BHP"):
    #        ndata += 1

    ndata = 81
    buffer = struct.pack(">llllf", 0, 0, ndata, 0, preamp_gain)

    # add pairs of (param_id, value) in big endian
    # it looks like Apple now sort them
    for param_id, value in sorted(params.items()):
        if param_id[0] in ("2"):
            # value is unsigned int https://developer.apple.com/documentation/audiotoolbox/audiounitparameterid
            # buffer += struct.pack(">ll", int(param_id), value)
            buffer += struct.pack(">lf", int(param_id), float(value))
        else:
            # value is a float
            buffer += struct.pack(">lf", int(param_id), value)

    # convert the byte buffer to base64
    text = base64.standard_b64encode(buffer).decode("ascii")

    # add \t and slice in chunks of 68 chars
    nchunks = 68
    len_text = len(text) // nchunks
    slices = [
        "\t{}\n".format(text[i * nchunks : (i + 1) * nchunks])
        for i in range(len_text)
    ]
    slices += ["\t{}".format(text[len_text * nchunks :])]

    return 0, len_iir, "".join(slices)


def iir2aupreset(iir: list, name: str) -> tuple[STATUS, str]:
    status, len, data = iir2data(iir)
    if status != 0:
        return status, ""
    return 0, AUPRESET_TEMPLATE.substitute(
        data=data, name=name, number_of_bands=len
    )
